---
title: 数据结构与算法（二）——线性表
date: 2024-01-18 09:29:17
description: 
categories: 
tags: 
top_image: 
cover: 
keywords:
---
# 线性表简介
## <font color = "886600">线性表的定义</font>
> <strong><font color = "#D35400">线性表（List）：零个或多个数据元素的有限序列</font></strong>

通过定义我们可以了解到，线性表是一个序列并且它所包含的数据元素是有限个的。在更形式化的表述中，线性表是一个n（n>=0）个数据元素的有序集合(a<sub>1</sub>，a<sub>2</sub>，a<sub>3</sub>，……，a<sub>n</sub>)，其中：
- <font color = "CC6600">「直接前驱元素」：</font>指一个数据元素在序列中的前一个位置上的那个数据元素。对于元素a<sub>2</sub>，元素a<sub>1</sub>即为其直接前驱
- <font color = "CC6600">「直接后继元素」：</font>指一个数据元素在序列中的后一个位置上的那个数据元素。对于元素a<sub>2</sub>，元素a<sub>3</sub>即为其直接后继
- <font color = "CC6600">「空表」：</font>通过定义了解到，线性表所包含的数据元素可以为零个，那么当线性表中不包含任何数据元素时，此时的线性表被称为空表

通过上述定义，我们了解了线性表的基础概念。在计算机中，线性表可以有两种不同的存储方式——顺序存储结构和链式存储结构，不同的存储结构会影响到表的操作效率，因此我们需要掌握这两种存储结构，以便能够选择正确的存储结构

## <font color = "886600">线性表的存储结构</font>
### <font color = "AA7700">线性表的顺序存储结构</font>
> <strong><font color = "#D35400">线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素</font></strong>

在线性表的顺序存储结构中，它的逻辑结构和物理结构是一致的，这意味着数据元素在表中的逻辑顺序与它们在内存中的物理位置是完全相同的。因此，可以直接通过元素的索引快速访问它们，这也是顺序存储结构可以实现随机存取的原因。

线性表的顺序存储结构示意图如下：
![线性表的顺序存储结构.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202401181126820.png)

如上图所示，线性表的顺序存储结构将数据元素存放在一组地址连续的存储单元中。例如，如果我们已知a<sub>4</sub>的内存地址是1006，那么a<sub>1</sub>的内存地址就是1006-3×2=1000（这里我们假设一个数据元素占用2个存储单元），而a<sub>6</sub>的地址就是1006+2×2=1010

我们可以看出，通过这种方式来查找任意一个数据元素所花费的时间复杂度都为O(1)，而满足这一特性的数据结构称为<font color = "CC6600">「随机存取结构」</font>

接下来我们简要说一说顺序存储结构的优缺点：
- 优点：
	- 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
	- 可以快速地存取表中任一位置的元素
- 缺点：
	- 插入和删除操作需要移动大量的数据元素
	- 当线性表长度变化大时，难以确定存储空间的容量
	- 造成存储空间的“碎片”

介绍完了线性表的顺序存储结构，接下来说一说线性表的链式存储结构，即：链表
### <font color = "AA7700">线性表的链式存储结构</font>
> <strong><font color = "#D35400">它是线性表的另一种存储方式。它使用一组任意的存储单元C存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</font></strong>

在链式存储结构中，除了要存储数据元素信息外，还需要存储它的后继元素的存储地址。以单链表为例，它的存储方式如下图所示：
![单链表存储结构.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202401181305407.png)
如上图所示，链表通过指针将一组任意的存储单元串联起来。其中，每个数据元素都包含一个<font color = "CC6600">「数据域」</font>和一个<font color = "CC6600">「指针域」</font>，数据域存储的是数据元素本身的信息，而指针域存储的则是它下一个数据元素的地址，该地址被称为<font color = "CC6600">「后继指针 next」</font>

在链表中，数据元素之间的逻辑关系依靠指针来间接反映。逻辑上相邻的数据元素在物理结构上可能是相邻的也可能是不相邻的，因此链表的物理结构不一定能够体现出它的逻辑结构

以下是链表的一些优缺点：
- 优点：
	- 链表不需要事先分配存储空间，只要有就可以分配，元素个数不受到限制
	- 链表的插入操作和删除操作，在事先知道数据元素的地址后，它们的时间复杂度仅为O(1)
- 缺点：
	- 占用内存空间大，因为它不仅需要存储自身的信息还需要存储下一个数据元素的地址信息
	- 因为链表不满足<font color = "CC6600">「随机存取结构」</font>，因此它的查找时间复杂度为O(n)
介绍完单链表之后，我们再来介绍一下<font color = "CC6600">「循环链表」</font>
#### <font color = "#B7950B">循环链表</font>
> <strong><font color = "#D35400">循环链表：循环链表是链表的一种变异形式。它的最后一个结点的指针域指向头结点，形成一个环</font></strong>

在单链表中，链表中的最后一个结点的指针域为空（^），因此我们无法通过任意一个结点找到它的前继结点。但是在循环链表中，它的最后一个结点的指针域不再为空，而是指向了链表的第一个数据元素，如下图所示：
![循环链表.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202401181614580.png)
在循环链表中，我们不再通过检查指针域是否为空来判断链表是否已经遍历完毕，而是通过检查指针是否回到了第一个数据元素。不过，由于在循环链表中进行插入或删除操作可能会改变第一个数据元素，这就使得识别链表的起始元素变得不那么直观。为了避免这种混淆，并简化操作，通常会在循环链表中引入一个无实际数据的辅助节点，<font color = "CC6600">「头结点」</font>。头结点是一个不包含实际数据的辅助结点，它的指针域指向链表的第一个实际数据结点。

头结点的引入具有以下的优点：
- 简化操作：通过头结点，我们可以在链表的头部统一插入和删除操作，即使链表为空也不例外
- 快速访问：通过头结点我们可以快速的访问第一个数据元素
- 遍历终止条件明确：当遍历到头结点后，意味着已经完成了一轮循环，这使得遍历的终止条件更加清晰

下图是引入了头结点的示意图：
![引入头结点的循环链表.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202401181633243.png)
因为最后一个节点的指针域始终指向不变的头结点，无论第一个数据元素如何变化，链表遍历的完成总是可以通过指针是否重新指向头结点来可靠判断。

虽然循环链表可以循环遍历整个链表，但我们需要获取当前数据元素的前一个数据元素依旧需要遍历整个链表，这将导致时间复杂度为O(n)，为了优化这一数据结构，我们将引入新的数据结构——<font color = "CC6600">「双向循环链表」</font>

#### <font color = "#B7950B">双向循环链表</font>
> <strong><font color = "#D35400">双向循环链表：双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</font></strong>

双向循环链表的示意图如下：
![双向循环链表.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202401181813926.png)
通过双向循环链表，我们可以很容易的获取当前结点的前一个结点

介绍完了链表的结构，接下来将以经典的<font color = "CC6600">「单链表」</font>为例，介绍一下单链表的基本操作

## <font color = "886600">抽象数据结构</font>
``` C#
ADT 线性表(List<T>)
Data
	线性表的数据对象集合为{a1,a2,a3,……,an}，每个元素的类型均为T。其中，除了第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系
Operation
	InitList()
		Result：初始化一个空集合
	InitList(IEnumerable<T>)
		Parameter
			IEnumerable<T>：不为空的集合
		Description：从已有的集合初始化一个线性表
	Add(T)：void
		Parameter
			T：要添加的数据元素
		Description：将新元素添加到线性表的末尾
	Add(T,int)：void
		Parameter
			T：要添加的数据元素
			int：元素要添加到的位置
		Description：在指定位置插入新元素到线性表
	Remove(int)：void
		Parameter
			int：要删除的数据元素的索引
		Description：移除线性表中指定索引处的元素
	Remove(T)：void
		Parameter
			T：要移除的元素值
		Description：移除线性表中第一个匹配的元素
	UpdateData(int,T)：void
		Parameter
			int：要更新的元素的索引
			T：新的元素值
		Description：更新指定索引处的元素值
	GetVal(int)：T
		Parameter
			int：要获取值的元素的索引
		Description：获取线性表中指定索引处的元素值
	GetCount()：int
		Description：获取线性表中数据元素的个数
	Clear()：void
		Description：移除线性表中的所有元素
```
# 链表的基本操作